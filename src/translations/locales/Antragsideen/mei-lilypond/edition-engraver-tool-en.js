    export default {
    
    (2523472,'<p>In this work package tools will be developed to process the graphical edits and generate rendering hints for the edition-engraver. This makes the work in <ac:link><ri:page ri:content-title=\"2.2.1 Manipulating SVG Scores\" /></ac:link> specific for the task of having <em>LilyPond </em>engrave scores from MEI data. Practically this work package is very close to the previous, and it will presumably be developed simultaneously, but conceptually they should be separate, as they produce separate libraries that are reusable in different contexts.</p><table><tbody><tr><td style=\"text-align: right;\"><strong>Type:</strong></td><td><p><em>Toolbox<br /></em></p></td></tr><tr><td style=\"text-align: right;\"><strong>Complexity:</strong></td><td>Medium</td></tr><tr><td colspan=\"1\" style=\"text-align: right;\"><strong>Technologies:</strong></td><td colspan=\"1\">JavaScript</td></tr><tr><td style=\"text-align: right;\"><strong>Dependencies:</strong></td><td><ac:link><ri:page ri:content-title=\"2.2.1 Manipulating SVG Scores\" /></ac:link>, <ac:link><ri:page ri:content-title=\"2.1.2 &ldquo;edition-engraver&ldquo;\" /><ac:plain-text-link-body><![CDATA[2.1.2 “edition-engraver“]]></ac:plain-text-link-body></ac:link></td></tr><tr><td style=\"text-align: right;\"><strong>State:</strong></td><td>--</td></tr></tbody></table><p style=\"text-align: right;\"><ac:link><ri:page ri:content-title=\"2.2.1 Manipulating SVG Scores\" /><ac:plain-text-link-body><![CDATA[<= Back]]></ac:plain-text-link-body></ac:link> || <ac:link><ri:page ri:content-title=\"2.2 Engrave Preview\" /><ac:plain-text-link-body><![CDATA[Up]]></ac:plain-text-link-body></ac:link> || <ac:link><ri:page ri:content-title=\"2.2.3 Interface for Page Layout etc.\" /><ac:plain-text-link-body><![CDATA[Next =>]]></ac:plain-text-link-body></ac:link></p><hr /><p>Generating tweaks from graphical edits is not completely trivial, as there are usually numerous ways in LilyPond to define a tweak. The package should be aware of different options depending on the type of object, and it should interact appropriately with the framework implemented in the previous work package: the numerical editing assistants should offer choices between different ways to tweak an item, correctly generating the values for each based on the actual graphical edit.</p><p>However, it should be configurable to what extent the user gets access to the diversity - the administrator of an edition should have the possibility to weigh the trade-off between flexibility and complexity. For example: in LilyPond it is always possible to hardcode the replacement of an object by overriding its <code>extra-offset</code> property. However, this should usually be the last resort as it actually blocks LilyPond\'s own layout engine, so it is a very unsustainable approach. However, for a one-time rendering this is completely irrelevant, so in an interface where a user can just apply some tweaks before printing a selected reading it might be the best solution to just offer this override without the user even knowing about it. Another complexity question to be considered is the number of tweakable properties for score elements in LilyPond. An &ldquo;object editor&rdquo; widget might be fed with a (generated) list of all properties the selected item supports - however, this would be a very advanced editing environment which the majority of users would not need (or even want to be confronted with).</p><p>This work package should produce an encapsulated library that uses the graphical manipulation library but doesn\'t necessarily need to provide bidirectional communication. It should be possible to use this library in arbitrary browser based LilyPond editing environments.</p>',2490878,2),

    
    }