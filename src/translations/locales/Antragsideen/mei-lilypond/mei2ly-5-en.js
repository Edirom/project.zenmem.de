    export default {
    
    (2523300,'<p>Parse an XML file and map its DOM to a Scheme representation that can be fed into LilyPond\'s rendering engine. This is a requirement to make LilyPond consume MEI data.</p><p>Generally speaking LilyPond\'s compilation proceeds in two subsequent stages: the parsing and the engraving. First the complete document is parsed and processed to some internal representation (although there is no single moment with a single hierarchical data structure object), which is then used as input for the rendering stage. The idea of <code>mei2ly</code> is to prepare such a representation from XML.</p><table><tbody><tr><td style=\"text-align: right;\"><strong>Type:</strong></td><td style=\"text-align: left;\">Fundamentals</td></tr><tr><td style=\"text-align: right;\"><strong>Complexity:</strong></td><td style=\"text-align: left;\">Medium to high</td></tr><tr><td style=\"text-align: right;\"><strong>Technology:</strong></td><td style=\"text-align: left;\">Scheme, (possibly C++)</td></tr><tr><td style=\"text-align: right;\"><strong>Dependencies:</strong></td><td style=\"text-align: left;\"><ac:link><ri:page ri:content-title=\"1.1.1 Update LilyPond to Guile v2\" /></ac:link></td></tr><tr><td colspan=\"1\" style=\"text-align: right;\"><strong>State:</strong></td><td colspan=\"1\" style=\"text-align: left;\">--</td></tr></tbody></table><p style=\"text-align: right;\"><ac:link><ri:page ri:content-title=\"1.1.1 Update LilyPond to Guile v2\" /><ac:plain-text-link-body><![CDATA[<= Back]]></ac:plain-text-link-body></ac:link> || <ac:link><ri:page ri:content-title=\"1.1 Data Structures/Formats\" /><ac:plain-text-link-body><![CDATA[Up]]></ac:plain-text-link-body></ac:link> || <ac:link><ri:page ri:content-title=\"1.1.2.1 Explore GridLY\" /><ac:plain-text-link-body><![CDATA[Next =>]]></ac:plain-text-link-body></ac:link></p><p style=\"text-align: right;\">&nbsp;</p><hr /><p>Substeps:</p><ac:task-list>\n<ac:task>\n<ac:task-id>7</ac:task-id>\n<ac:task-status>incomplete</ac:task-status>\n<ac:task-body><span>Read XML to SXML (Scheme\'s XML representation)</span></ac:task-body>\n</ac:task>\n<ac:task>\n<ac:task-id>5</ac:task-id>\n<ac:task-status>incomplete</ac:task-status>\n<ac:task-body><span>Convert this SXML to a Scheme object that can be fed into a <code>(make-music)</code> call</span></ac:task-body>\n</ac:task>\n<ac:task>\n<ac:task-id>6</ac:task-id>\n<ac:task-status>incomplete</ac:task-status>\n<ac:task-body><span>Infrastructure to actually do the above and have LilyPond process it</span></ac:task-body>\n</ac:task>\n</ac:task-list>\n<p style=\"text-align: left;\"><span>It is not clear whether this should be added to LilyPond itself or if it is better suited as an openLilyLib package. In any case development should be done in openLilyLib.</span></p><h5 style=\"text-align: left;\"><span>XML format</span></h5><p><span>It has to be explored what is a suitable XML format for the intermediate stage. In order to develop a generically usable solution this is not necessarily MEI directly. It seems useful to have an XML document whose structure matches that of a LilyPond document as closely as possible. This will then make it possible to convert arbitrary XML formats (e.g. MusicXML too) to a usable format through available technology such as XSLT.</span></p><p><span>There is another approach to be considered: <em>Lychee</em>. <br />The <em>nCoda</em> project located in Canada is working on a new web based notation system, with an &ldquo;MEI arbiter&rdquo; at its core. This will be a tool that can convert to and from numerous formats, taking a slightly stripped down MEI - <em>Lychee MEI</em> - as its intermediate format. Lychee and its companion tools and technologies will be presented at the MEC 2016, and we are already discussing how and where our work can be coordinated. It has to be explored if <code>mei2ly</code> can take Lychee MEI as its standardized input format.</span></p><p>&nbsp;</p>',2490676,2),

    
    }