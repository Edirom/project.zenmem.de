export default {

(28540936,'<h1>Bereiche</h1><p>Im Confluence wurden bisher zwei Bereiche angelegt, die bei der Arbeit im Zentrum unterst&uuml;tzen sollen. Dabei handelt es sich um die Bereiche ZenMEM (F&uuml;r die Organisation untereinander und wissenschaftliche Erkenntnisse) und Edirom (Technische Dokumentation der Software-Entwicklungen). Dies schlie&szlig;t aber nicht aus, dass noch weitere Bereiche eingerichtet werden. Es ist durchaus denkbar, dass sich Kleingruppen in eigenen Bereichen organisieren.</p><h2>ZenMEM</h2><p>Dieser Bereich dient vor allem der Organisation der Mitarbeiter im Zentrum. Hier werden die grundlegenden Prozesse und Arbeitsweisen im Zentrum beschrieben. Zudem ist dies auch der Ablageort f&uuml;r die Protokolle der einzelnen Treffen. S&auml;mtliche Aufgaben, die nicht direkt mit der Entwicklung der Software zu tun haben, werden an dieser Stelle gesammelt und sollten von jedem MItarbeiter sofern sie erledigt wurden, abgehakt werden. Unterst&uuml;tzt wird dieser Bereich mit einem eigenen Kalender (ZenMEM). Er soll zudem Ablageort f&uuml;r How-To Artikel f&uuml;r das Zentrum sein. Die Dokumentation der wissenschaftlichen Erkenntnisse und Vorgehensweisen innerhalb des Zentrums werden ebenfalls in diesem Bereich durchgef&uuml;hrt. Dazu geh&ouml;ren z. B. die Leitf&auml;den der Interviews und z. M. die kondensierten Ergebnisse. Ein Abgleich des Projektstatus mit den Meilensteinen f&uuml;r den Projekttr&auml;ger finden ebenfalls an dieser Stelle statt (siehe hierf&uuml;r <ac:link><ri:page ri:content-title=\"Arbeitspakete\" ri:space-key=\"ZEN\" /></ac:link>).</p><h2>Edirom</h2><p>Der Bereich Edirom dient f&uuml;r die technische Dokumentation der im Zentrum entwickelten Software. Im Allgemeinen soll diese mit agilen Entwicklungsmethoden, vor allem Scrum entwickelt werden. Daher werden an dieser Stelle die grundlegende Architektur, Rahmenbedingungen und grundlegenden Design-Entscheidungen dokumentiert. Dies stellt das Fundament f&uuml;r das Backlog eines Scrum Entwicklungsprozesses dar. F&uuml;r die konkrete Entwicklung werden unter dem Subbereich System-Features die einzelnen zu entwickelnden Features des Systems an dieser Stelle mit Aufgabenmodellen, Mockups, Anforderungen, etc. dokumentiert. Zudem wird eine Verkn&uuml;pfung zu einer konkreten Epic im JIRA erstellt. Die einzelnen Epics in&nbsp;JIRA k&ouml;nnen mit User Stories anhand dieser Dokumentation verfeinert werden und im Anschluss f&uuml;r Sprint Backlogs verwendet werden.</p><h1>Prozesse</h1><h1>Dokumentation</h1><p>F&uuml;r die Dokumentation der im Zentrum entwickelten Software werden die Modelle und Werkzeuge wie in Abbildung 1 zu erkennen, eingesetzt. Die Dokumentationssprache ist hierbei Englisch, um eine OpenSource Entwicklung zu vereinfachen. Der zentrale Ausgangspunkt f&uuml;r die Dokumentation ist das Aufgabenmodell (Task model).</p><p><ac:structured-macro ac:name=\"gliffy\"><ac:parameter ac:name=\"name\">Tools</ac:parameter><ac:parameter ac:name=\"border\">true</ac:parameter><ac:parameter ac:name=\"size\">500</ac:parameter></ac:structured-macro></p><p style=\"text-align: left;\">Abbildung 1: Diagramme und Werkzeuge, die in ZenMEM verwendet werden sollen.</p><h2>Aufgaben-Modelle (Task model)</h2><p>&nbsp;</p><p><ac:image ac:height=\"503\" ac:width=\"1273\"><ri:attachment ri:filename=\"CatalogueSources.png\" /></ac:image></p><p>Abbildung 2: Aufgabenmodell</p><p>Das Fundament der Anforderungen und Dokumentation der Software stellt das Aufgabenmodell dar. Dieses ist baumartig aufgebaut und besteht aus Knoten, die die Ziele bzw. Aufgaben aus Benutzersicht in einer nicht-technischen Weise beschreiben. Das Besondere hierbei ist die schrittweise Verfeinerung der Aufgaben je tiefer der Baum gegangen wird. Das bedeutet, dass ein Ziel / eine Aufgabe weiter oben im Baum durch die Ziele / Aufgaben unter ihm repr&auml;sentiert werden. Die Blattknoten sind somit die kleinsten Ziele, die in einem Aufgabenmodell auftauchen und sollen &auml;hnlich wie Use Cases m&ouml;glichst in sich abgeschlossene Handlungsfolgen repr&auml;sentieren. Als Heuristik kann auch hier verwendet werden, dass die richtige Gr&ouml;&szlig;e erreicht wurde, wenn der Nutzer nach Abschluss des Ziels/Aufgabe einen Schluck Kaffee trinken w&uuml;rde/k&ouml;nnte.&nbsp;</p><p>In Abbildung 2 ist ein Teilausschnitt aus dem Aufgabenmodell f&uuml;r den Edirom Editor abgebildet. Das spezielle am Aufgabenmodell im Vergleich zu Use Cases ist die M&ouml;glichkeit temporale Relationen zwischen den einzelnen Knoten direkt anzugeben. Bei UseCases w&uuml;rde hierf&uuml;r ein extra Aktivit&auml;tendiagramm ben&ouml;tigt. Diese temporalen Relationen werden in Hamsters als extra Knoten dargestellt. Folgende m&ouml;gliche temporalen Relationen existieren in Hamsters:</p><p>T1&gt;&gt;T2 -&gt; Aufgabe T2 wird nach T1 ausgef&uuml;hrt</p><p>T1|||T2 -&gt; Parallele Ausf&uuml;hrung von T1 und T2</p><p>T1[]T2 -&gt; Ausf&uuml;hrung entweder von T1 oder T2</p><p>T1[&gt;T2 -&gt; Ausf&uuml;hrung von T2 unterbricht die Ausf&uuml;hrung von T1</p><p>T1|&gt;T2 -&gt; Ausf&uuml;hrung von T2 unterbricht die Ausf&uuml;hrung von T1. Die Ausf&uuml;hrung von T1 wird fortgesetzt, wenn die Aufgabe T2 beendet wurde</p><p>T1|=|T2 -&gt; Reihenfolge der Ausf&uuml;hrung ist nicht festgelegt</p><p>F&uuml;r Abbildung 2 als Beispiel bedeutet dies: Um eine Quelle katalogisieren (CatalogueSources) zu k&ouml;nnen, muss zuerst entscheiden werden, ob ein Werk (MusicalComposition), ein Notentext (MusicalNotation), ein Dokument (engl. Document) oder Mediendateien als Quelle vorliegen. Ist die Entscheidung f&uuml;r ein Werk gefallen, muss zus&auml;tzlich einen Titel (InputTitel) und ein Komponist (InputComposerName) angeben werden.Nun wird die Quelle katalogisiert und die Aufgabe als abgeschlossen markiert.</p><p>Aufgabenmodelle k&ouml;nnen entweder bottom-up oder top-down erstellt werden. F&uuml;r top-down bietet sich beispielsweise die hierarchische Aufgabenanalyse (hierarchical task analysis (hta), siehe&nbsp;[1]) an. F&uuml;r Bottom-Up k&ouml;nnen zuerst Use-Case DIagramme wie im Abschnitt Use Case Diagramme erstellt werden und diese Use Cases dann in das Aufgabenmodell &uuml;bertragen werden.</p><h2>Tier-architecture diagram</h2><p>Im n&auml;chsten Schritt wird anhand des Aufgabenmodells ein &Uuml;berblicksdiagramm der verwendeten Komponenten erstellt. Die einzelnen Knoten werden in Schichten &uuml;bersetzt und die notwendigen zus&auml;tzlichen technischen Eigenschaften hinzugef&uuml;gt.</p><h2>Mockups</h2><p>&nbsp;</p><p><ac:image ac:height=\"400\"><ri:attachment ri:filename=\"mockup02_catalogue-sources.png\" /></ac:image></p><p>&nbsp;</p><p><ac:image ac:height=\"400\"><ri:attachment ri:filename=\"mockup03_catalogue-sources-create.png\" /></ac:image></p><p>&nbsp;</p><p>&nbsp;</p><h2>Dom&auml;nen-Modelle (Domain model)</h2><p>Ein Dom&auml;nenmodell in der Softwareentwicklung ist ein konzeptuelles Modell des Problemdomainbereichs, das die Schl&uuml;sselkonzepte und Domainwissens eines konkreten Problems beschreibt. Das Dom&auml;nenmodell besteht aus Einheiten (Entities), ihren Attributen und den Relationen (Relationships) zwischen den einzelnen Einheiten. Im Unterschied zu einem allgemeinen Klassendiagramm, beschr&auml;nkt sich dieses Modell nur auf dem Problembereich und beschreibt somit keine Probleml&ouml;sungen, also keine Gesch&auml;ftslogik. Das Dom&auml;nenmodell kann als Basis f&uuml;r die Erstellung eines Dialogmodells eingesetzt werden. Zudem kann das Dom&auml;nenmodell der Ausgangspunkt f&uuml;r die Erstellung eines Datenmodells f&uuml;r die Datenhaltung darstellen.</p><p>&nbsp;</p><p><ac:image ac:height=\"400\"><ri:attachment ri:filename=\"domainModelNEW.png\" /></ac:image></p><p>Abbildung 3: Dom&auml;nenmodell</p><p>Auf Abbildung 3 wird ein Ausschnitt des Dom&auml;nenmodells dargestellt. Dieser besteht u. a. aus den Entities &bdquo;Source&ldquo;, &bdquo;SourceStore&ldquo;, &bdquo;Movement&ldquo; und &bdquo;Page&ldquo;. Die Eintities enthalten die Attribute. Assoziationen zwischen Einheiten entsprechen den Relationen. Bei den Beziehungen k&ouml;nnen die Kardinalit&auml;ten bestimmt werden. Erlaubt sind die Folgende: 1-N und N-N. Bezogen auf das Beispiel bedeutet es folgendes:</p><p>&bull; Ein Source kann in mehreren SourceStore enthalten sein, und ein SourceStore kann ebenso in mehreren Source-Einheiten enthalten (N-N);</p><p>&bull; Source referenziert mehrere Page-Einheiten, und Jede Page-Einheit ist mit genau einer Source-Einheit verkn&uuml;pft (1-N);</p><p>&bull; Jedem Source werden mehrere Movements zugeordnet, und jedes Movement kann mehreren Sources zugeordnet werden (N-N);</p><p>&bull; Jedem Movement k&ouml;nnen weitere unterliegende Movements zugeordnet werden, und eine Menge von Movements kann mit einem oberliegenden Movement verkn&uuml;pft werden (1-N).</p><p>&nbsp;</p><ul><li>Klassen/Objekte identifizieren, Klassen/Objekte beschreiben,</li><li>Attribute festlegen, Attribute beschreiben,</li><li>Beziehungen festlegen, Beziehungen beschreiben,</li><li>Operationen festlegen, Operationen beschreiben.</li></ul><h2>Use-Case Diagramme</h2><p>Use-Case Diagramme verschaffen einen ersten groben &Uuml;berblick, &uuml;ber die M&ouml;glichkeiten der zu entwickelnden Software.</p><p><ac:structured-macro ac:name=\"gliffy\"><ac:parameter ac:name=\"name\">UseCase1</ac:parameter></ac:structured-macro></p><h2><ac:structured-macro ac:name=\"gliffy\"><ac:parameter ac:name=\"name\">UseCase2</ac:parameter></ac:structured-macro></h2><h2>Epics</h2><h2>Schnittstellendefinition</h2><h2>Referenzen</h2><p>[1] Kieras, D., Model-Based Evaluation, in The Human-Computer Interaction Handbook - Fundamentals, Evolving Technologies, and Emerging Applications, Jacko, J. A., 3rd Edition, 2012, Taylor &amp; Francis Group</p><p>&nbsp;</p>',28508170,2),

};